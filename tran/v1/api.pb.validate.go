// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: tran/v1/api.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ChainListRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChainListRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChainListRequestMultiError, or nil if none found.
func (m *ChainListRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainCode

	if len(errors) > 0 {
		return ChainListRequestMultiError(errors)
	}

	return nil
}

// ChainListRequestMultiError is an error wrapping multiple validation errors
// returned by ChainListRequest.ValidateAll() if the designated constraints
// aren't met.
type ChainListRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListRequestMultiError) AllErrors() []error { return m }

// ChainListRequestValidationError is the validation error returned by
// ChainListRequest.Validate if the designated constraints aren't met.
type ChainListRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListRequestValidationError) ErrorName() string { return "ChainListRequestValidationError" }

// Error satisfies the builtin error interface
func (e ChainListRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListRequestValidationError{}

// Validate checks the field values on ChainListResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ChainListResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChainListResultMultiError, or nil if none found.
func (m *ChainListResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChainCode

	// no validation rules for Code

	// no validation rules for ContractAddress

	if len(errors) > 0 {
		return ChainListResultMultiError(errors)
	}

	return nil
}

// ChainListResultMultiError is an error wrapping multiple validation errors
// returned by ChainListResult.ValidateAll() if the designated constraints
// aren't met.
type ChainListResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListResultMultiError) AllErrors() []error { return m }

// ChainListResultValidationError is the validation error returned by
// ChainListResult.Validate if the designated constraints aren't met.
type ChainListResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListResultValidationError) ErrorName() string { return "ChainListResultValidationError" }

// Error satisfies the builtin error interface
func (e ChainListResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListResultValidationError{}

// Validate checks the field values on ChainListReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChainListReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChainListReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChainListReplyMultiError,
// or nil if none found.
func (m *ChainListReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ChainListReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChainListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChainListReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChainListReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChainListReplyMultiError(errors)
	}

	return nil
}

// ChainListReplyMultiError is an error wrapping multiple validation errors
// returned by ChainListReply.ValidateAll() if the designated constraints
// aren't met.
type ChainListReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChainListReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChainListReplyMultiError) AllErrors() []error { return m }

// ChainListReplyValidationError is the validation error returned by
// ChainListReply.Validate if the designated constraints aren't met.
type ChainListReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChainListReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChainListReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChainListReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChainListReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChainListReplyValidationError) ErrorName() string { return "ChainListReplyValidationError" }

// Error satisfies the builtin error interface
func (e ChainListReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChainListReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChainListReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChainListReplyValidationError{}

// Validate checks the field values on IsMultiSigAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsMultiSigAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsMultiSigAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsMultiSigAddressRequestMultiError, or nil if none found.
func (m *IsMultiSigAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IsMultiSigAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetWalletAddress()) < 2 {
		err := IsMultiSigAddressRequestValidationError{
			field:  "WalletAddress",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsMultiSigAddressRequestMultiError(errors)
	}

	return nil
}

// IsMultiSigAddressRequestMultiError is an error wrapping multiple validation
// errors returned by IsMultiSigAddressRequest.ValidateAll() if the designated
// constraints aren't met.
type IsMultiSigAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsMultiSigAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsMultiSigAddressRequestMultiError) AllErrors() []error { return m }

// IsMultiSigAddressRequestValidationError is the validation error returned by
// IsMultiSigAddressRequest.Validate if the designated constraints aren't met.
type IsMultiSigAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsMultiSigAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsMultiSigAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsMultiSigAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsMultiSigAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsMultiSigAddressRequestValidationError) ErrorName() string {
	return "IsMultiSigAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsMultiSigAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsMultiSigAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsMultiSigAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsMultiSigAddressRequestValidationError{}

// Validate checks the field values on IsMultiSigAddressReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IsMultiSigAddressReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IsMultiSigAddressReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IsMultiSigAddressReplyMultiError, or nil if none found.
func (m *IsMultiSigAddressReply) ValidateAll() error {
	return m.validate(true)
}

func (m *IsMultiSigAddressReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	if len(errors) > 0 {
		return IsMultiSigAddressReplyMultiError(errors)
	}

	return nil
}

// IsMultiSigAddressReplyMultiError is an error wrapping multiple validation
// errors returned by IsMultiSigAddressReply.ValidateAll() if the designated
// constraints aren't met.
type IsMultiSigAddressReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsMultiSigAddressReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsMultiSigAddressReplyMultiError) AllErrors() []error { return m }

// IsMultiSigAddressReplyValidationError is the validation error returned by
// IsMultiSigAddressReply.Validate if the designated constraints aren't met.
type IsMultiSigAddressReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsMultiSigAddressReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsMultiSigAddressReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsMultiSigAddressReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsMultiSigAddressReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsMultiSigAddressReplyValidationError) ErrorName() string {
	return "IsMultiSigAddressReplyValidationError"
}

// Error satisfies the builtin error interface
func (e IsMultiSigAddressReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsMultiSigAddressReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsMultiSigAddressReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsMultiSigAddressReplyValidationError{}

// Validate checks the field values on BalanceRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceRequestMultiError,
// or nil if none found.
func (m *BalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetWalletAddress()) < 2 {
		err := BalanceRequestValidationError{
			field:  "WalletAddress",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ContractAddress

	if len(errors) > 0 {
		return BalanceRequestMultiError(errors)
	}

	return nil
}

// BalanceRequestMultiError is an error wrapping multiple validation errors
// returned by BalanceRequest.ValidateAll() if the designated constraints
// aren't met.
type BalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceRequestMultiError) AllErrors() []error { return m }

// BalanceRequestValidationError is the validation error returned by
// BalanceRequest.Validate if the designated constraints aren't met.
type BalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceRequestValidationError) ErrorName() string { return "BalanceRequestValidationError" }

// Error satisfies the builtin error interface
func (e BalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceRequestValidationError{}

// Validate checks the field values on BalanceResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceResultMultiError, or
// nil if none found.
func (m *BalanceResult) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Balance

	// no validation rules for Multisig

	if len(errors) > 0 {
		return BalanceResultMultiError(errors)
	}

	return nil
}

// BalanceResultMultiError is an error wrapping multiple validation errors
// returned by BalanceResult.ValidateAll() if the designated constraints
// aren't met.
type BalanceResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceResultMultiError) AllErrors() []error { return m }

// BalanceResultValidationError is the validation error returned by
// BalanceResult.Validate if the designated constraints aren't met.
type BalanceResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceResultValidationError) ErrorName() string { return "BalanceResultValidationError" }

// Error satisfies the builtin error interface
func (e BalanceResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceResultValidationError{}

// Validate checks the field values on BalanceReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceReplyMultiError, or
// nil if none found.
func (m *BalanceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BalanceReplyMultiError(errors)
	}

	return nil
}

// BalanceReplyMultiError is an error wrapping multiple validation errors
// returned by BalanceReply.ValidateAll() if the designated constraints aren't met.
type BalanceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceReplyMultiError) AllErrors() []error { return m }

// BalanceReplyValidationError is the validation error returned by
// BalanceReply.Validate if the designated constraints aren't met.
type BalanceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceReplyValidationError) ErrorName() string { return "BalanceReplyValidationError" }

// Error satisfies the builtin error interface
func (e BalanceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceReplyValidationError{}

// Validate checks the field values on SendTranRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendTranRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTranRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendTranRequestMultiError, or nil if none found.
func (m *SendTranRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTranRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mnemonic

	// no validation rules for PrivKey

	// no validation rules for From

	// no validation rules for To

	// no validation rules for ContractAddress

	// no validation rules for Value

	// no validation rules for ObjectId

	if len(errors) > 0 {
		return SendTranRequestMultiError(errors)
	}

	return nil
}

// SendTranRequestMultiError is an error wrapping multiple validation errors
// returned by SendTranRequest.ValidateAll() if the designated constraints
// aren't met.
type SendTranRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTranRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTranRequestMultiError) AllErrors() []error { return m }

// SendTranRequestValidationError is the validation error returned by
// SendTranRequest.Validate if the designated constraints aren't met.
type SendTranRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTranRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTranRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTranRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTranRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTranRequestValidationError) ErrorName() string { return "SendTranRequestValidationError" }

// Error satisfies the builtin error interface
func (e SendTranRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTranRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTranRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTranRequestValidationError{}

// Validate checks the field values on SendTranResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTranResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTranResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTranResultMultiError,
// or nil if none found.
func (m *SendTranResult) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTranResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	// no validation rules for Msg

	if len(errors) > 0 {
		return SendTranResultMultiError(errors)
	}

	return nil
}

// SendTranResultMultiError is an error wrapping multiple validation errors
// returned by SendTranResult.ValidateAll() if the designated constraints
// aren't met.
type SendTranResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTranResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTranResultMultiError) AllErrors() []error { return m }

// SendTranResultValidationError is the validation error returned by
// SendTranResult.Validate if the designated constraints aren't met.
type SendTranResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTranResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTranResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTranResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTranResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTranResultValidationError) ErrorName() string { return "SendTranResultValidationError" }

// Error satisfies the builtin error interface
func (e SendTranResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTranResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTranResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTranResultValidationError{}

// Validate checks the field values on SendTranReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SendTranReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTranReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SendTranReplyMultiError, or
// nil if none found.
func (m *SendTranReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTranReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendTranReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendTranReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendTranReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendTranReplyMultiError(errors)
	}

	return nil
}

// SendTranReplyMultiError is an error wrapping multiple validation errors
// returned by SendTranReply.ValidateAll() if the designated constraints
// aren't met.
type SendTranReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTranReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTranReplyMultiError) AllErrors() []error { return m }

// SendTranReplyValidationError is the validation error returned by
// SendTranReply.Validate if the designated constraints aren't met.
type SendTranReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTranReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTranReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTranReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTranReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTranReplyValidationError) ErrorName() string { return "SendTranReplyValidationError" }

// Error satisfies the builtin error interface
func (e SendTranReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTranReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTranReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTranReplyValidationError{}

// Validate checks the field values on HeightRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeightRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeightRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeightRequestMultiError, or
// nil if none found.
func (m *HeightRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HeightRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HeightRequestMultiError(errors)
	}

	return nil
}

// HeightRequestMultiError is an error wrapping multiple validation errors
// returned by HeightRequest.ValidateAll() if the designated constraints
// aren't met.
type HeightRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeightRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeightRequestMultiError) AllErrors() []error { return m }

// HeightRequestValidationError is the validation error returned by
// HeightRequest.Validate if the designated constraints aren't met.
type HeightRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeightRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeightRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeightRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeightRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeightRequestValidationError) ErrorName() string { return "HeightRequestValidationError" }

// Error satisfies the builtin error interface
func (e HeightRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeightRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeightRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeightRequestValidationError{}

// Validate checks the field values on HeightReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeightReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeightReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeightReplyMultiError, or
// nil if none found.
func (m *HeightReply) ValidateAll() error {
	return m.validate(true)
}

func (m *HeightReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	// no validation rules for Data

	if len(errors) > 0 {
		return HeightReplyMultiError(errors)
	}

	return nil
}

// HeightReplyMultiError is an error wrapping multiple validation errors
// returned by HeightReply.ValidateAll() if the designated constraints aren't met.
type HeightReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeightReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeightReplyMultiError) AllErrors() []error { return m }

// HeightReplyValidationError is the validation error returned by
// HeightReply.Validate if the designated constraints aren't met.
type HeightReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeightReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeightReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeightReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeightReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeightReplyValidationError) ErrorName() string { return "HeightReplyValidationError" }

// Error satisfies the builtin error interface
func (e HeightReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeightReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeightReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeightReplyValidationError{}

// Validate checks the field values on GetBlockHashByHeightRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBlockHashByHeightRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBlockHashByHeightRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBlockHashByHeightRequestMultiError, or nil if none found.
func (m *GetBlockHashByHeightRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBlockHashByHeightRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Height

	if len(errors) > 0 {
		return GetBlockHashByHeightRequestMultiError(errors)
	}

	return nil
}

// GetBlockHashByHeightRequestMultiError is an error wrapping multiple
// validation errors returned by GetBlockHashByHeightRequest.ValidateAll() if
// the designated constraints aren't met.
type GetBlockHashByHeightRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBlockHashByHeightRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBlockHashByHeightRequestMultiError) AllErrors() []error { return m }

// GetBlockHashByHeightRequestValidationError is the validation error returned
// by GetBlockHashByHeightRequest.Validate if the designated constraints
// aren't met.
type GetBlockHashByHeightRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBlockHashByHeightRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBlockHashByHeightRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBlockHashByHeightRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBlockHashByHeightRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBlockHashByHeightRequestValidationError) ErrorName() string {
	return "GetBlockHashByHeightRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBlockHashByHeightRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBlockHashByHeightRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBlockHashByHeightRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBlockHashByHeightRequestValidationError{}

// Validate checks the field values on TxResult with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TxResultMultiError, or nil
// if none found.
func (m *TxResult) ValidateAll() error {
	return m.validate(true)
}

func (m *TxResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	// no validation rules for From

	// no validation rules for To

	// no validation rules for TokenTransaction

	// no validation rules for ContractAddress

	// no validation rules for Status

	// no validation rules for Value

	// no validation rules for Fee

	// no validation rules for Date

	if len(errors) > 0 {
		return TxResultMultiError(errors)
	}

	return nil
}

// TxResultMultiError is an error wrapping multiple validation errors returned
// by TxResult.ValidateAll() if the designated constraints aren't met.
type TxResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxResultMultiError) AllErrors() []error { return m }

// TxResultValidationError is the validation error returned by
// TxResult.Validate if the designated constraints aren't met.
type TxResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxResultValidationError) ErrorName() string { return "TxResultValidationError" }

// Error satisfies the builtin error interface
func (e TxResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxResultValidationError{}

// Validate checks the field values on Utxo with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Utxo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Utxo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UtxoMultiError, or nil if none found.
func (m *Utxo) ValidateAll() error {
	return m.validate(true)
}

func (m *Utxo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for IsAddress

	if len(errors) > 0 {
		return UtxoMultiError(errors)
	}

	return nil
}

// UtxoMultiError is an error wrapping multiple validation errors returned by
// Utxo.ValidateAll() if the designated constraints aren't met.
type UtxoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UtxoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UtxoMultiError) AllErrors() []error { return m }

// UtxoValidationError is the validation error returned by Utxo.Validate if the
// designated constraints aren't met.
type UtxoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UtxoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UtxoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UtxoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UtxoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UtxoValidationError) ErrorName() string { return "UtxoValidationError" }

// Error satisfies the builtin error interface
func (e UtxoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUtxo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UtxoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UtxoValidationError{}

// Validate checks the field values on TxUtxo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxUtxo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxUtxo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TxUtxoMultiError, or nil if none found.
func (m *TxUtxo) ValidateAll() error {
	return m.validate(true)
}

func (m *TxUtxo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	for idx, item := range m.GetFrom() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TxUtxoValidationError{
						field:  fmt.Sprintf("From[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TxUtxoValidationError{
						field:  fmt.Sprintf("From[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TxUtxoValidationError{
					field:  fmt.Sprintf("From[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TxUtxoValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TxUtxoValidationError{
						field:  fmt.Sprintf("To[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TxUtxoValidationError{
					field:  fmt.Sprintf("To[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	// no validation rules for Fee

	// no validation rules for Date

	if len(errors) > 0 {
		return TxUtxoMultiError(errors)
	}

	return nil
}

// TxUtxoMultiError is an error wrapping multiple validation errors returned by
// TxUtxo.ValidateAll() if the designated constraints aren't met.
type TxUtxoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxUtxoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxUtxoMultiError) AllErrors() []error { return m }

// TxUtxoValidationError is the validation error returned by TxUtxo.Validate if
// the designated constraints aren't met.
type TxUtxoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxUtxoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxUtxoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxUtxoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxUtxoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxUtxoValidationError) ErrorName() string { return "TxUtxoValidationError" }

// Error satisfies the builtin error interface
func (e TxUtxoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxUtxo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxUtxoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxUtxoValidationError{}

// Validate checks the field values on BalanceChanges with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceChanges) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceChanges with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceChangesMultiError,
// or nil if none found.
func (m *BalanceChanges) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceChanges) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Owner

	// no validation rules for CoinType

	// no validation rules for Amount

	if len(errors) > 0 {
		return BalanceChangesMultiError(errors)
	}

	return nil
}

// BalanceChangesMultiError is an error wrapping multiple validation errors
// returned by BalanceChanges.ValidateAll() if the designated constraints
// aren't met.
type BalanceChangesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceChangesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceChangesMultiError) AllErrors() []error { return m }

// BalanceChangesValidationError is the validation error returned by
// BalanceChanges.Validate if the designated constraints aren't met.
type BalanceChangesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceChangesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceChangesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceChangesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceChangesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceChangesValidationError) ErrorName() string { return "BalanceChangesValidationError" }

// Error satisfies the builtin error interface
func (e BalanceChangesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceChanges.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceChangesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceChangesValidationError{}

// Validate checks the field values on TxBalance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxBalance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TxBalanceMultiError, or nil
// if none found.
func (m *TxBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *TxBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	for idx, item := range m.GetBalanceChanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TxBalanceValidationError{
						field:  fmt.Sprintf("BalanceChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TxBalanceValidationError{
						field:  fmt.Sprintf("BalanceChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TxBalanceValidationError{
					field:  fmt.Sprintf("BalanceChanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TxBalanceMultiError(errors)
	}

	return nil
}

// TxBalanceMultiError is an error wrapping multiple validation errors returned
// by TxBalance.ValidateAll() if the designated constraints aren't met.
type TxBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxBalanceMultiError) AllErrors() []error { return m }

// TxBalanceValidationError is the validation error returned by
// TxBalance.Validate if the designated constraints aren't met.
type TxBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxBalanceValidationError) ErrorName() string { return "TxBalanceValidationError" }

// Error satisfies the builtin error interface
func (e TxBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxBalanceValidationError{}

// Validate checks the field values on BlockResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockResultMultiError, or
// nil if none found.
func (m *BlockResult) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	// no validation rules for Height

	for idx, item := range m.GetTxs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockResultValidationError{
						field:  fmt.Sprintf("Txs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockResultValidationError{
						field:  fmt.Sprintf("Txs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockResultValidationError{
					field:  fmt.Sprintf("Txs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return BlockResultMultiError(errors)
	}

	return nil
}

// BlockResultMultiError is an error wrapping multiple validation errors
// returned by BlockResult.ValidateAll() if the designated constraints aren't met.
type BlockResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockResultMultiError) AllErrors() []error { return m }

// BlockResultValidationError is the validation error returned by
// BlockResult.Validate if the designated constraints aren't met.
type BlockResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockResultValidationError) ErrorName() string { return "BlockResultValidationError" }

// Error satisfies the builtin error interface
func (e BlockResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockResultValidationError{}

// Validate checks the field values on GetBlockHashByHeightReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBlockHashByHeightReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBlockHashByHeightReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBlockHashByHeightReplyMultiError, or nil if none found.
func (m *GetBlockHashByHeightReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBlockHashByHeightReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Code

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBlockHashByHeightReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBlockHashByHeightReplyValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBlockHashByHeightReplyValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBlockHashByHeightReplyMultiError(errors)
	}

	return nil
}

// GetBlockHashByHeightReplyMultiError is an error wrapping multiple validation
// errors returned by GetBlockHashByHeightReply.ValidateAll() if the
// designated constraints aren't met.
type GetBlockHashByHeightReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBlockHashByHeightReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBlockHashByHeightReplyMultiError) AllErrors() []error { return m }

// GetBlockHashByHeightReplyValidationError is the validation error returned by
// GetBlockHashByHeightReply.Validate if the designated constraints aren't met.
type GetBlockHashByHeightReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBlockHashByHeightReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBlockHashByHeightReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBlockHashByHeightReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBlockHashByHeightReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBlockHashByHeightReplyValidationError) ErrorName() string {
	return "GetBlockHashByHeightReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetBlockHashByHeightReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBlockHashByHeightReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBlockHashByHeightReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBlockHashByHeightReplyValidationError{}
